// Jopnal lighting shader plugin file
//
// Jopnal license applies.

// Required uniforms for lighting calculations
//
// Required by both lighting and shadows
//
#plugin <Jopnal/DefaultLighting/Uniforms>

	#include <Jopnal/DefaultLighting/Structures>

    uniform Material u_Material;

    #if JMAT_MAX_POINT_LIGHTS > 0

        uniform PointLightInfo u_PointLights[JMAT_MAX_POINT_LIGHTS];
        uniform samplerCube u_PointLightShadowMaps[JMAT_MAX_POINT_LIGHTS];
        uniform int u_NumPointLights;

    #endif

    #if JMAT_MAX_SPOT_LIGHTS > 0

        uniform SpotLightInfo u_SpotLights[JMAT_MAX_SPOT_LIGHTS];
        uniform sampler2D u_SpotLightShadowMaps[JMAT_MAX_SPOT_LIGHTS];
        uniform int u_NumSpotLights;

    #endif

    #if JMAT_MAX_DIRECTIONAL_LIGHTS > 0

        uniform DirectionalLightInfo u_DirectionalLights[JMAT_MAX_DIRECTIONAL_LIGHTS];
        uniform sampler2D u_DirectionalLightShadowMaps[JMAT_MAX_DIRECTIONAL_LIGHTS];
        uniform int u_NumDirectionalLights;

    #endif

#pluginend

// Default lighting functions
//
//
#plugin <Jopnal/DefaultLighting/Lighting>

    #if JMAT_MAX_POINT_LIGHTS > 0
        
        // Point light calculation
        void jop_CalculatePointLight(const in int index, out vec3 ambient, out vec3 diffuse, out vec3 specular)
        {
            PointLightInfo l = u_PointLights[index];

            #if __VERSION__ < 300

                if (!l.enabled)
                {
                    ambient = vec3(0.0);
                    diffuse = vec3(0.0);
                    specular = vec3(0.0);
                }

            #endif

            // Ambient impact
            ambient = l.ambient * vec3(u_Material.ambient);

            // Normal vector
            vec3 norm = normalize(vf_Normal);

            // Direction from fragment to light
            vec3 lightDir = normalize(l.position - vf_Position);

            // Diffuse impact
            float diff = max(dot(norm, lightDir), 0.0);
            diffuse = diff * l.diffuse * vec3(u_Material.diffuse);

            // Direction from fragment to eye
            vec3 viewDir = normalize(-vf_Position);

            // Calculate reflection direction (use a half-way vector)
            vec3 reflectDir = normalize(lightDir + viewDir);

            float shininess = max(1.0, u_Material.shininess

            #ifdef JMAT_GLOSSMAP
                * JOP_TEXTURE_2D(u_GlossMap, vf_TexCoords).a
            #endif
            );

            // Specular impact
            float spec = (8.0 + shininess) / (8.0 * 3.14159265) * pow(max(dot(norm, reflectDir), 0.0), shininess);

            specular = l.specular * spec * vec3(u_Material.specular)

            #ifdef JMAT_SPECULARMAP
                * vec3(JOP_TEXTURE_2D(u_SpecularMap, vf_TexCoords))
            #endif
            ;

            // Attenuation
            float dist = length(l.position - vf_Position);
            float attenuation = 1.0 / (l.attenuation.x + l.attenuation.y * dist + l.attenuation.z * (dist * dist));
            ambient *= attenuation; diffuse *= attenuation; specular *= attenuation;

            // Shadow calculation
            if (l.castShadow && u_ReceiveShadows)
            {
                float shadow = jop_CalculatePointShadow(lightDir, l.farPlane, u_PointLightShadowMaps[index]);

                diffuse *= (1.0 - shadow);
                specular *= (1.0 - shadow);
            }
        }

    #endif

    #if JMAT_MAX_SPOT_LIGHTS > 0

        // Spot light calculation
        void jop_CalculateSpotLight(const in int index, out vec3 ambient, out vec3 diffuse, out vec3 specular)
        {
            SpotLightInfo l = u_SpotLights[index];

            #if __VERSION__ < 300

                if (!l.enabled)
                {
                    ambient = vec3(0.0);
                    diffuse = vec3(0.0);
                    specular = vec3(0.0);
                }

            #endif

            // Ambient impact
            ambient = l.ambient * vec3(u_Material.ambient);

            // Normal vector
            vec3 norm = normalize(vf_Normal);

            // Direction from fragment to light
            vec3 lightDir = normalize(l.position - vf_Position);

            // Diffuse impact
            float diff = max(dot(norm, lightDir), 0.0);
            diffuse = l.diffuse * diff * vec3(u_Material.diffuse);

            // Direction from fragment to eye
            vec3 viewDir = normalize(-vf_Position);

            // Calculate reflection direction (use a half-way vector)
            vec3 reflectDir = normalize(lightDir + viewDir);

            float shininess = max(1.0, u_Material.shininess

            #ifdef JMAT_GLOSSMAP
                * JOP_TEXTURE_2D(u_GlossMap, vf_TexCoords).a
            #endif
            );

            // Specular impact
            float spec = (8.0 + shininess) / (8.0 * 3.14159265) * pow(max(dot(norm, reflectDir), 0.0), shininess);

            specular = l.specular * spec * vec3(u_Material.specular)

            #ifdef JMAT_SPECULARMAP
                * vec3(JOP_TEXTURE_2D(u_SpecularMap, vf_TexCoords))
            #endif
            ;

            // Spotlight soft edges
            float theta = dot(lightDir, normalize(-l.direction));
            float epsilon = (l.cutoff.x - l.cutoff.y);
            float intensity = clamp((theta - l.cutoff.y) / epsilon, 0.0, 1.0);
            ambient *= intensity; diffuse *= intensity; specular *= intensity;

            // Attenuation
            float dist = length(l.position - vf_Position);
            float attenuation = 1.0 / (l.attenuation.x + l.attenuation.y * dist + l.attenuation.z * (dist * dist));
            ambient *= attenuation; diffuse *= attenuation; specular *= attenuation;

            // Shadow calculation
            if (l.castShadow && u_ReceiveShadows)
            {
                vec4 tempCoords = l.lsMatrix * vec4(vf_Position, 1.0);

                float shadow = jop_CalculateDirSpotShadow((tempCoords.xyz / tempCoords.w) * 0.5 + 0.5, norm, lightDir, u_SpotLightShadowMaps[index]);

                diffuse *= (1.0 - shadow);
                specular *= (1.0 - shadow);
            }
        }

    #endif

    #if JMAT_MAX_DIRECTIONAL_LIGHTS > 0

        // Directional light calculation
        void jop_CalculateDirectionalLight(const in int index, out vec3 ambient, out vec3 diffuse, out vec3 specular)
        {
            DirectionalLightInfo l = u_DirectionalLights[index];

            #if __VERSION__ < 300

                if (!l.enabled)
                {
                    ambient = vec3(0.0);
                    diffuse = vec3(0.0);
                    specular = vec3(0.0);
                }

            #endif

            // Ambient impact
            ambient = l.ambient * vec3(u_Material.ambient);

            // Normal vector
            vec3 norm = normalize(vf_Normal);

            // Direction from light to fragment.
            // Directional light shines infinitely in the same direction,
            // so no need to take fragment position into account
            vec3 lightDir = normalize(-l.direction);

            // Diffuse impact
            float diff = max(dot(norm, lightDir), 0.0);
            diffuse = l.diffuse * diff * vec3(u_Material.diffuse);

            // Direction from fragment to eye
            vec3 viewDir = normalize(-vf_Position);

            // Calculate reflection direction (use a half-way vector)
            vec3 reflectDir = normalize(lightDir + viewDir);

            float shininess = max(1.0, u_Material.shininess

            #ifdef JMAT_GLOSSMAP
                * JOP_TEXTURE_2D(u_GlossMap, vf_TexCoords).a
            #endif
            );

            // Specular impact
            float spec = (8.0 + shininess) / (8.0 * 3.14159265) * pow(max(dot(norm, reflectDir), 0.0), shininess);

            specular = l.specular * spec * vec3(u_Material.specular)

            #ifdef JMAT_SPECULARMAP
                * vec3(JOP_TEXTURE_2D(u_SpecularMap, vf_TexCoords))
            #endif
            ;

            // No attenuation calculations here
            // Directional Light is infinite, Directional Light is eternal

            // Shadow calculation
            if (l.castShadow && u_ReceiveShadows)
            {
                float shadow = jop_CalculateDirSpotShadow(vec3(l.lsMatrix * vec4(vf_Position, 1.0)) * 0.5 + 0.5, norm, lightDir, u_DirectionalLightShadowMaps[index]);

                diffuse *= (1.0 - shadow);
                specular *= (1.0 - shadow);
            }
        }

    #endif

#pluginend