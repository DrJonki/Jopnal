// Jopnal lighting shader plugin file
//
// Jopnal license applies.

// Required uniforms for lighting calculations
//
// Required by both lighting and shadows
//
#plugin <Jopnal/DefaultLighting/Uniforms>

	// Material
	struct Material
	{
	    vec4 ambient;
	    vec4 diffuse;
	    vec4 specular;
	    vec4 emission;
	
	    float shininess;
	    float reflectivity;
	};
	uniform Material u_Material;

    #if JMAT_MAX_POINT_LIGHTS > 0

        // Point lights
        struct PointLightInfo
        {
            bool enabled;

            // Position
            vec3 position;

            // Intensities
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;

            // Attenuation
            // x = constant
            // y = linear
            // z = quadratic
            vec3 attenuation;

            // Shadow map info
            bool castShadow;    ///< Cast shadows?
            float farPlane;     ///< The light's far plane
        };
        uniform PointLightInfo u_PointLights[JMAT_MAX_POINT_LIGHTS];
        uniform samplerCube u_PointLightShadowMaps[JMAT_MAX_POINT_LIGHTS];
        uniform int u_NumPointLights;

    #endif



#pluginend

// Default lighting functions
//
//
#plugin <Jopnal/DefaultLighting/Lighting>

	#if JMAT_MAX_POINT_LIGHTS > 0

        #if __VERSION__ >= 300
        
            // Offset directions for sampling point shadows
            const vec3 g_gridSamplingDisk[20] = vec3[]
            (
                vec3(1, 1,  1), vec3( 1, -1,  1), vec3(-1, -1,  1), vec3(-1, 1,  1),
                vec3(1, 1, -1), vec3( 1, -1, -1), vec3(-1, -1, -1), vec3(-1, 1, -1),
                vec3(1, 1,  0), vec3( 1, -1,  0), vec3(-1, -1,  0), vec3(-1, 1,  0),
                vec3(1, 0,  1), vec3(-1,  0,  1), vec3( 1,  0, -1), vec3(-1, 0, -1),
                vec3(0, 1,  1), vec3( 0, -1,  1), vec3( 0, -1, -1), vec3( 0, 1, -1)
            );

        #endif
        
        // Point light calculation
        void jop_CalculatePointLight(const in int index, out vec3 ambient, out vec3 diffuse, out vec3 specular)
        {
            PointLightInfo l = u_PointLights[index];

            #if __VERSION__ < 300
                if (!l.enabled)
                    return vec3(0.0);
            #endif

            // Ambient impact
            ambient = l.ambient * vec3(u_Material.ambient);

            // Normal vector
            vec3 norm = normalize(vf_Normal);

            // Direction from fragment to light
            vec3 lightDir = normalize(l.position - vf_FragPosition);

            // Diffuse impact
            float diff = max(dot(norm, lightDir), 0.0);
            diffuse = diff * l.diffuse * vec3(u_Material.diffuse);

            // Direction from fragment to eye
            vec3 viewDir = normalize(u_CameraPosition - vf_FragPosition);

            // Calculate reflection direction (use a half-way vector)
            vec3 reflectDir = normalize(lightDir + viewDir);

            float shininess = max(1.0, u_Material.shininess

            #ifdef JMAT_GLOSSMAP
                * JOP_TEXTURE_2D(u_GlossMap, vf_TexCoords).a
            #endif
            );

            // Specular impact
            float spec = (8.0 + shininess) / (8.0 * 3.14159265) /*<< energy conservation */ * pow(max(dot(norm, reflectDir), 0.0), shininess);

            specular = l.specular * spec * vec3(u_Material.specular)

            #ifdef JMAT_SPECULARMAP
                * vec3(JOP_TEXTURE_2D(u_SpecularMap, vf_TexCoords))
            #endif
            ;

            // Attenuation
            float dist = length(l.position - vf_FragPosition);
            float attenuation = 1.0 / (l.attenuation.x + l.attenuation.y * dist + l.attenuation.z * (dist * dist));
            ambient *= attenuation; diffuse *= attenuation; specular *= attenuation;

            // Shadow calculation
            if (l.castShadow && u_ReceiveShadows)
            {
                // Get a vector between fragment and light positions
                vec3 fragToLight = vf_FragPosition - l.position;

                // Test for shadows with PCF
            #if __VERSION__ >= 300

                // Get current linear depth as the length between the fragment and light position
                float currentDepth = length(fragToLight);

                float shadow = 0.0;
                const float bias = 0.15;
                const int samples = 20;

                float viewDistance = length(u_CameraPosition - vf_FragPosition);
                float diskRadius = (1.0 + (viewDistance / l.farPlane)) / 25.0;
                for (int i = 0; i < samples; ++i)
                {
                    vec3 samp = fragToLight + g_gridSamplingDisk[i] * diskRadius;
                    
                    float closestDepth = JOP_TEXTURE_CUBE(u_PointLightShadowMaps[index], samp).r;

                    // Undo mapping [0,1]
                    closestDepth *= l.farPlane;

                    if (currentDepth - bias > closestDepth)
                        shadow += 1.0;
                }
                shadow /= float(samples);

            #else

                float closestDepth = JOP_TEXTURE_CUBE(u_PointLightShadowMaps[index], fragToLight).r;

                closestDepth *= l.farPlane;

                float currentDepth = length(fragToLight);

                const float bias = 0.05;

                float shadow = currentDepth - bias > closestDepth ? 1.0 : 0.0;

            #endif

                diffuse *= (1.0 - shadow);
                specular *= (1.0 - shadow);
            }
        }

    #endif

#pluginend